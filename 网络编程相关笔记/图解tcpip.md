# 网络基础知识

**7层网络模型**

**7 应用层**

**6 表示层	 	数据格式的转换。把设备的数据格式转换成网络标准传输格式。**

**5 会话层		管理何时建立链接，何时发送数据。**

**4 传输层		建立逻辑上的链接，接受方也会把数据没有接受完整告知主机a**

​						**保证数据传输可靠性**

**3 网络层		数据进行实际传输的层**

**2 数据链路层**

**1 物理层**

## 传输方式的分类：

### 	面向有连接型

​		tcp/ip

### 	面向无连接型

​		udp

## 接收端数量分类：

### 		单播

### 		广播

### 		多播

### 		任播

## 1.8 地址设计

​	单一性，层次性

相比：

​	MAC地址 只有唯一性。无层次性。

​	IP地址 只有唯一性。无层次性。

同样 ，MAC 地址寻址 相比于IP地址寻址方法。

IP地址寻址 ：怎么实现寻址？

## 1.9 网络构成要素

![image-20200216194648592](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200216194648592.png)



### 1.9.1 

​	带宽和吞吐量

#### 1.9.2 网卡

#### 1.9.3 中继器 ---作用在物理层

#### 1.9.4 网桥/2层交换机 ----作用在数据链路层

​	根据物理地址（mac地址）进行分发

#### 1.9.5 路由器/3层交换机

​	根据IP地址进行处理。

#### 1.9.6 4-7层交换机

#### 1.9.7 网关

​	负责将从传输层到应用层数据进行转换和转发的设备。

​	翻译和转发数据

​	应用： 代理服务器。

### 1.10 网络实况

​	逻辑链路 看起来一样的

但是物理链路上不一定是一样的链路，但是看起来是一样的。

# 第二章 tcpip 基础知识

由7层变成4层

![image-20200216202558699](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200216202558699.png)

### IP

​	IP协议属于非t可靠传输协议。

### 传输层

​	tcp：面向有连接的传输层协议

​	udp：面向无连接的传输层协议。

### 应用层

​	www 万维网 ：协议为http  传输数据主要格式是HTML

​	文件传输（ftp）

​	远程登陆（ssh）

## tcp/ip 分层模型

​		![image-20200217044134806](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217044134806.png)

下一层角度中，上一层所有的包都是本层的数据。

![image-20200217045750873](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217045750873.png)

数据添加在首部的信息。

接收端对于各个协议的处理：

​	网络接口

​	ip模块的处理

​	tcp模块的处理

​	应用程序的处理

# 第三章 数据链路

# 	数据链路作用

​	数据链路的段

### 3.2.1 mac地址

​	每一个网卡的mac地址都是固定的，不会重复。

但是在虚拟机上，也不是一定唯一的存在。

### 3.2.2 共享介质型网络

#### 	争用方式怎么处理？

#### 	令牌传递方式

​		只有在网络拥堵的时候有效，平时都不能到100 的利用率 

### 3.2.3 非共享介质网络

​	半双工：类似对讲机
和全双工通信：类似电话

### 3.2.4 根据mac地址转发

​	以太网交换机----》转发表

<img src="C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217065147830.png" alt="image-20200217065147830" style="zoom:80%;" />

#### 		

进表

### 3.2.6 VLAN

不需要修改网络布线，只需要改变网络拓扑。就可以改变网段。

改变vlan标签就可以改变网段。

## 3.3 **以太网（ethernet）

## 3.4 无线通信 （3g，4g）

​	无线WAN 属于数据链路层的协议分类/

# 第四章 网络层

![image-20200217223328290](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217223328290.png)

这几个问题的答案



ip 层 ： 面向无连接。不提供可靠服务。只负责交付

A类地址，B类地址，C类地址

![image-20200217165856557](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217165856557.png)

地址在分配的时候，只分配网络号，主机号由单位自己分配。

## 地址解析协议ARP/还有RARP

​	用来对应 IP地址 到 硬件地址。

方式：在主机ARP	缓存里面加入一个映射表。

​	如果映射表中没有相关主机的信息，就进行一次ARP广播，寻找ip地址对应的硬件地址。另外，所有的映射都设置生存时间。

​	如果不在同一个局域网。就通过路由器进行ARP请求分组，找到对应主机。这个事是直到所有局域网的主机都没有响应的时候才进行下一步。

​	逐步询问路径----不会直接划分路径。

RARP 是用来主机 硬件地址映射于IP地址的协议。



## 子网和超网

从2级IP地址到3级IP地址。

就是普通的IP转换成了子网形式的ip地址。-----》3级IP地址。

借用主机号来充当子网号。

但是本身的数据报没法看到是否有子网划分了。所以引入了子网掩码进行判断。

一定程度上，不同子网掩码和IP地址 AND 得出的网络地址是相同的。

**注意，网络地址和IP地址的稍微差别。**

## 网络控制报文协议ICMP

常见指令ping 和  traceroute：查找到达目的地址要经过的路由器IP地址

## 互联网的路由选择协议

### 内部网关协议和外部网关协议可以不一致。

内部IGP

外部EGP

![image-20200217182618894](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217182618894.png)

RIP

​	当某个路由器收到相邻路由器的消息，要根据需求修改

1. 该目的网络是不是还没有

2. 该目的网络的下一跳路由器是不是就是这个相邻的路由器。

3. 该目的网络的距离是不是变小了

   **缺点是网络出现问题后，要很长时间才传到所有的路由器。**

OSPF 

​	洪泛法：flooding 广播的形式发送到所有的路由器

外部网关协议 BGP

​	目的：不是找到最短的路径，而是找到一个最好得路径。

### IPV6

32位到128位，数据报首部不兼容

数据报分为基本首部和有效载荷。有效载荷中允许有扩展首部。后面再接着数据部分。

取消了检验和字段。

取消了广播，把它归类到多播中得一个特例。

#### 过渡：

1，双协议栈

当DNS 返回什么类型地址，就使用什么类型得地址

2.隧道技术。

​	把IPV6粉装成IPV4的数据部分。脱离IPV4的主机后，一切正常。

###  IP 多播

多播不能写入目的IP地址，因为有很多新加入的主机。所以用的是多播组的标识符。

​	局域网上进行硬件多播

​	互联网上进行多播

### 虚拟专用网VPN 和网络地址转换NAT

![image-20200217214642671](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217214642671.png)

这些网段都是专用网，或者称为本地互联网。

VPN知识看起来像是专用网，其实是用了隧道技术的互联网。

![image-20200217215328627](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217215328627.png)

其实还是要经过互联网访问，只是在传输的过程中进行加密了。

#### 那么在，专用网内部的本地机如果想要访问互联网主机。怎么办？

NAT

每个路由器至少需要一个互联网地址，但本地主机需要和外部通信的时候，就可以把本地IP变成路由器的那个IP ，进行通信。有N台全球IP 的地址的路由器，就允许有N台主机访问到湖联网。

只能本地的主机发起，不能由互联网的主机发起。

### MPLS 多协议标记交换

对IP数据报打label ---》分类。

label的更新和替换。

好处，自定义管理网络流量。负载均衡。

# 第五章 运输层

​	![image-20200217223222317](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217223222317.png)

这几个知识点 要弄清楚

### 运输层协议概述

1.从主机之间的通信再进一步到主机进程之间的通信。

更加细化。 更加端对端的通信是进程之间的通信。

复用：

​	不同进程都是使用同一个运输层

分用：

​	接受方运输层剥去报文后可以准确送到对应应用进程。

另外，运输层需要进行**差错检测**，

运输层保证了信道是否可靠---->TCP OR UDP;

TCP: TCP 报文段

UDP:UDP 用户数据报。

TCP提供可靠的面向连接的运输服务。

#### 需要给对应的进程加上对应的标志，不能随机分发。

​	协议端口号，port；在进程通信中，不仅需要知道目的的IP地址，还需要知道进程占用的端口号。

![image-20200217232456929](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217232456929.png)

![image-20200217232523245](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217232523245.png)

## 用户数据报协议UDP

​	udp 是无连接的。发送之前不需要连接。

​	udp 不保证可靠交付。

**udp 面向报文

​		处理很简单，只是在报文前端加上UDP首部，不做其他任何操作，报文切割功能交给应用层来保证。

​	udp 无拥塞控制

​		适用在视频会议这一种类似的实时应用上。

​	udp 支持一对一，一对多，多对一，多对多 的交互通信。

​	udp 首部开销小。8字节对应TCP的20字节、

工作原理：	

​		如果接受方UDP发现收到的报文的目的端口号不正确，则立马丢掉，然后发送端口不可达差错报文到发送方。

**不需要用到套接字socket**，虽然要用到端口号保证目的地，但是不用建立连接。

## 传输控制协议TCP

### 	最主要特点：

​	1.在传送数据之前，已经建立了TCP连接，在传送完毕之后，释放连接。------**socket，blind，listen，open，close**

2. TCP连接中只有两个端点。只能点对点形式存在。
3. TCP提供可靠交付的服务。
4. 全双工通信。
   1. 两端设置缓存。够了再发送或者再接受，-----》粘包？
5. 面向字节流
   1. tcp不理解应用层给的字节块含义，只是理解成字节流，不保证识别能力，所以不一定会发送一整块的信息过去，有权自己切割内容发送。

### TCP连接

​	端点的定义：socket  =（IP地址，端口）

![image-20200217235523270](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200217235523270.png)

所以一个ip地址由很多tcp连接，一个端口也会再很多tcp连接出现。

### 如何保证可靠传输呢？

理想情况是：

​	1.传输信道不产生差错。

​	2.不过发送方多块，接收方都能来得及处理数据。

#### 停止等待协议（ARQ协议）

​	因为接受方只是被动等待，什么都不做，发送方只是超时重传，所以会出现当确认丢失后，A又再次超时重传，B再次收到新的M1.

​	很慢，但是适合在不可靠的传输网络中实现可靠的通信。而且信道利用率太低。

#### 连续ARQ协议

​	为了提高信道利用率，流水线传输。

当发送方有一个确认的时候，就往前划动一格

![image-20200218045649238](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218045649238.png)

返回确认也只需要返回最后那个收到的分组确认。

#### TCP报文段的首部格式

![image-20200218050250123](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218050250123.png)

确认ACK

推送PSH	

复位RST

同步SYN

终止FIN

窗口

后面还有时间戳可以和序号一起使用，避免带宽太大，一下子序号全部用完，这样可以保证序号的循环没那么块。

#### TCP可靠传输实现

![image-20200218053226731](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218053226731.png)

接受方只对按序收到的数据的最高序号给出确认。

发送方有三个指针，如果确认了几个单位，P3 和P1可以移动，但是p2不等到确认到42.都不移动。

![image-20200218054810430](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218054810430.png)

发送窗口 and 接收窗口

#### 超时重传时间的选择和判断。

### TCP流量控制

用发送窗口和接受窗口进行流量控制。

确认ack中还有接受窗口rwnd的大小。

这里要注意，发送窗口不能大于接受窗口，可以适当小于它。

### TCP拥塞控制

实际就是防止过多的数据注入到网络中，可以使得网络中路由器和链路不至于过载。其是一个全局性的过程。

相比之下，流量控制一般只是点对点通信量的控制，是一个端对端的问题。

#### 开环控制和闭环控制

闭环控制：基于反馈环路的概念。

​	监测网络系统，

​	把拥塞发生的信息传送到可采取行动的地方。

​	调整系统



#### 拥塞控制方法：

4个：慢开始，拥塞避免，快重传，快恢复。

------

慢开始：由小到大逐渐增大发送窗口，

刚开始的时候，设置CWND =1,等到接受到M1的确认，CWND 翻倍，然后继续等到确认。再确认后，再翻倍。

![image-20200218175834784](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218175834784.png)



​	但是翻倍也有可能导致拥塞窗口CWND 增大过大导致网络拥塞，添加一个慢开始门限。ssthresh.

------

​	拥塞避免算法：可以让拥塞窗口 CWND 缓慢增大，每次确认后拥塞窗口 CWND 加一。

​	加法增大

![image-20200218181046270](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218181046270.png)



![image-20200218181235489](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218181235489.png)



这里在4中，只是慢开始已经不适用全部情况了，所以还要加上快重传算法，为什么？

因为在4点位置，它收到了前面的对同一报文段的重复确认。虽然不是网络拥塞，但是还是把它慢开始了。要解决这个问题，就要用快重传和快恢复。

​	

------

​	快重传算法

​	要让发送方尽快知道知道发生了个别报文段的丢失。

​	就是即使收到失序的报文段，接受方也要及时发出之前的确认报文，例如

![image-20200218182100061](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218182100061.png)

当发送方收到3个重复确认时候，就立即进行重传，这样发送方不会误认为出现网络拥塞。这样就发送方知道了快重传算法，所以换采用快恢复算法。	

快恢复中，CWND 不会变成1，而是变成SSTHRESH的初始值。

![image-20200218183040421](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218183040421.png)



-----》加法增大 AI  和   乘法减小  MD。

#### 主动队列管理AQM

​	不等到最后队列满了才丢弃分组，而是提前设定一个最小门限和最大门限。

​	在最小和最大之间，随机丢弃。

![image-20200218183800212](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218183800212.png)

### TCP运输连接管理

#### 	TCP 连接建立

​			3次握手

![image-20200218183946820](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218183946820.png)

1. 同步位SYN =1，初始序号seq 不确定。设为x+1；

2. 接受方接收到后，发出同步位SYN =1，确定位ACK 设为1，为自己选择一个自己的初始序号y，确认号 ack =x+1；

3. 发送发收到后，自己的序号 x+1，确认号为 y+1；

4. 握手结束，数据传送。

   

   **ps.  如果别人问什么是四次握手，就是指的是，在接受方收到消息后，同步位文段和确认位文段分开发送。**

   **ps. 确认号都是确认别人的信息。**

为什么是3次 握手而不是2次握手。

​	因为要确认接受方的确认。

#### TCP连接释放

​	4次挥手

​	重点在于服务器方，就是接受方要连续两次发送确认，第一次确认前，client进入的时FIN-WAIT-1状态，这时候client已经是不在发送消息了，但是它可能还需要接受消息，所以这个是半关闭状态，client在这里一直挂着，等着server再次发送第三次挥手，已经没有数据可以发送了。这时候，ack 还是u+1.

​	client收到后，要确认server的确认，所以需要client发送一个确认报文到server

![image-20200218201821262](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218201821262.png)

这就是4次挥手。

如果第四次一直没收到，b就会重传第三次报文，

注意这个等待2MSL时间，因为首先第四次可能没收到，另外，防止在下次连接中，还接受到上次遗留下来的报文，。但是B不需要等待，因为所有都是A发出的要求。

![image-20200218203202185](C:\Users\fuckoff\AppData\Roaming\Typora\typora-user-images\image-20200218203202185.png)

​	





### 