# 题目描述：

给定一个长度为 n 的整数数组 nums，数组中所有的数字都在 0∼n−1 的范围内。
数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。
请找出数组中任意一个重复的数字。
注意：如果某些数字不在 0∼n−1 的范围内，或数组中不包含重复数字，则返回 -1；
样例
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。

# 解题思路：
## 1.暴力破解版：两次遍历，找到相同的，最坏情况是0（n2）；不贴代码
## 2.哈希表存数据后，再找出她的second值，超过一的输出；
## 3.来源：acwing（yxc）//排名第一
因为数据保证了<0 || >n 是不存在的；
原理：**== 桶排序+swap  ==*
数据大小是有范围的，并且小于长度，所以可以保证元素与索引可以一一对应，
那么，在遍历的过程中，把元素交换到索引处，实现简单排序。

x= nums【i】，x还要先和i比较，==相等，说明位置对了，不需要改变了==，直接跳过。而且i是从头递增的，跳过可以保证数据不会不完整。
x与num【x】比较，    如果不等，==交换位置--swap==
如果相等，说明x至少有两个，输出x。


    class Solution {
    public:
        int duplicateInArray(vector<int>& nums) {
            //set<int> temp;
            //异或不能解决，因为出现不止1个2次
            int n =nums.size();
            for(auto i : nums){
                if(i<0||i>n-1) return -1;
            }
            for(int i =0;i<n;i++){
                int x = nums[i];
                if(x!=i){
                    if(nums[x] != x){
                        swap(nums[x],x);
                    }
                    else return x;
                }
            }
            return -1;
        }
    };


